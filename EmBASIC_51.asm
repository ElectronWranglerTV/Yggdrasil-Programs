;* Yggdrasil (TM) Core Operating System: EmBASIC Embedded BASIC for 8051
;* Copyright (C) DeRemee Systems, IXE Electronics LLC
;* Portions copyright IXE Electronics LLC, Republic Robotics, FemtoLaunch, FemtoSat, FemtoTrack, Weland
;* This work is made available under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
;* To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/.

$INCLUDE (System.inc)


;$IF (BASIC = 1)

EXTRN	CODE	(DPTRWLDXDNN)
EXTRN	CODE	(FIFOCREATE,	FIFOINIT,	FIFOREADSTR)
EXTRN	CODE	(INTASC2WORD)
EXTRN	CODE	(MEMALCINT,	MEMALCXRAM)
EXTRN CODE	(STDLINEIN,	STDLINEOUTFLASH)
EXTRN CODE	(STRCHARATEND,	STRISNUM,	STRSLICE2FIFO)
;EXTRN	CODE	(LXBEECMDSEND)

PUBLIC	BASIC

BASIC_ROUTINES	SEGMENT		CODE

RSEG	BASIC_ROUTINES

	;KEYWORDS
	;--------------------
	;ADC		VARIABLE_NAME
	;	+ AVERAGE(SAMPLE_COUNT)
	;	+ DECIMATE(SAMPLE_COUNT)
	;	+ SETGAIN(VALUE)
	;	+ SETGND
	;	+ SETPIN(PIN_NUMBER)
	;	+ SETTEMP
	;	+ SETVDD
	;BOOL		VARIABLE_NAME
	;CHAR		VARIABLE_NAME
	;FLOAT	VARIABLE_NAME
	;INT		VARIABLE_NAME
	;	+ ABS
	;	+ ACOS
	;	+ ASIN
	;	+ ATAN
	;	+	COS
	;	+ POW
	;	+ SIN
	;	+ SQRT
	;	+ TAN
	;	+ TOSTRING
	;	+ TOFLOAT
	;STRING		VARIABLE_NAME
	;	+ LEFT(COUNT)
	;	+ LENGTH
	;	+ MID(START, COUNT)
	;	+ REPLACE(CHARACTER_TARGET, CHARACTER)										;REPLACES EVERY OCCURENCE OF CHARACTER_TARGET WITH CHARACTER
	;	+ RIGHT(COUNT)
	;	+ SPLIT(CHARACTER)																				;SPLITS THE STRING INTO AN ARRAY OF STRINGS, WHERE CHARACTER IS THE DELIMITER
	;	+ STRIP(CHARACTER)																				;REMOVES ALL OCCURRANCES IF CHARACTER FROM THE STRING
	;	+ TOCHAR																									;SPLITS THE STRING INTO AN ARRAY OF INDIVIDUAL CHARACTERS
	;	+ TOFLOAT
	;	+ TOINT
	;	+ TOLOWER
	;	+ TOUPPER
	;TASK			VARIABLE_NAME
	;	+ PAUSE
	;	+ SPLIT
	;LOCATE(X, Y)
	;PEEK(ADDRESS)
	;POKE(ADDRESS, BYTE)
	;PRINT(INTEGER)
	;PRINT(STRING)
	;TYPE (TYPE_NAME)

	;BASIC CONTROL BLOCK FORMAT


	;BASIC
	BASIC	PROC
			;PRINT BASIC TITLE & COPYRIGHT
			;ALLOCATE MEMORY
			MOV		R0, #0x00
			MOV		R1, #0x05
			CALL	MEMALCXRAM
			JNC		BASICA
			;monkaS WE HAVE A MEMORY ALLOCATION ERROR
			JMP		BASICERRMEM
		BASICA:
			;SAVE MEMORY ADDRESS
			MOV		DPL, R0
			MOV		DPH, R1
			MOV		R6, DPL
			MOV		R7, DPH
			;INITIALIZE SYSTEM VARIABLES
			;TASK CONTROL BLOCK
			CLR		A
			MOVX	@DPTR, A				;FLAGS
			INC		DPTR
			MOVX	@DPTR, A				;LINE INDEX POINTER
			INC		DPTR
			MOVX	@DPTR, A
			INC		DPTR
			MOVX	@DPTR, A				;LINE COUNT
			INC		DPTR
			MOVX	@DPTR, A
			INC		DPTR
			MOVX	@DPTR, A				;CURRENT LINE NUMBER
			INC		DPTR
			MOVX	@DPTR, A
			INC		DPTR
			MOV		A, #LINE_STEP_VALUE
			MOVX	@DPTR, A
			INC		DPTR
			;INITIALIZE FIFO SYSTEM & CREATE FIFO
			CALL	FIFOINIT
			JNC		BASICC
		BASICB:
			;monkaS WE HAVE A FIFO ERROR
			JMP		BASICERRFIFO
		BASICC:
			MOV		R0, #0x40
			CALL	FIFOCREATE
			JC		BASICB
			MOV		A, R0
			MOVX	@DPTR, A
			;PRINT PROMPT
			MOV		DPTR, #PROMPT
			CALL	STDLINEOUTFLASH
			JNC		BASICE
		BASICD:
			;PepeHands WE HAD A STDIO ERROR
			JMP		BASICERRSTDIO
		BASICE:
			;GET LINE FROM USER
			MOV		DPTR, #0x0800
			MOV		A, #0x40
			CALL	STDLINEIN
			JC		BASICD
			;SPLIT LINE INTO SUBSTRINGS AND PUT INTO FIFO
			MOV		A, R7
			MOV		R0, A
			CLR		A
			MOV		B, #0x20
			CALL	STRSLICE2FIFO
			JC		BASICB
			;READ FIRST STRING FROM FIFO
			CALL	FIFOREADSTR
			JC		BASICB
			;IS STRING NUMERIC?
			CLR		A
			CALL	STRISNUM
			JNC		BASICF
			;LINE NUMBER FOUND, PROCESS LINE NUMBER
			CALL	BASICLINENUMBER
			JMP		$
		BASICF:
			;LINE NUMBER NOT FOUND, CHECK FOR LINE NAME
			CALL	STRCHARATEND
			XRL		A, #':'
			JNZ		BASICG
			CALL	BASICLINELABEL
			JMP		$
			;LINE NAME NOT FOUND, TRY TO EXECUTE LINE
		BASICG:
	ENDP

	BASICARITHADD	PROC
			JMP $
	ENDP

	BASICARITHDIV	PROC
			JMP $
	ENDP

	BASICARITHFAC	PROC
			JMP $
	ENDP

	BASICARITHMUL	PROC
			JMP $
	ENDP

	BASICARITHSUB	PROC
			JMP $
	ENDP

	BASICASSIGN	PROC
			JMP $
	ENDP

	BASICBITAND	PROC
			JMP	$
	ENDP

	BASICBITOR	PROC
			JMP	$
	ENDP

	BASICBITROL	PROC
			JMP	$
	ENDP

	BASICBITROR	PROC
			JMP	$
	ENDP

	BASICBITSHL	PROC
			JMP	$
	ENDP

	BASICBITSHR	PROC
			JMP	$
	ENDP

	BASICBITXOR	PROC
			JMP	$
	ENDP

	BASICCMDLIST	PROC
			JMP	$
	ENDP

	BASICCMDNEW	PROC
			JMP	$
	ENDP

	BASICCMDRUN	PROC
			JMP	$
	ENDP

	;ERROR HANDLER FOR FIFO ERRORS
	BASICERRFIFO	PROC
			JMP	$
	ENDP

	BASICERRMEM	PROC
			JMP	$
	ENDP

	;ERROR HANDLER FOR STDIO ERRORS
	BASICERRSTDIO	PROC
			JMP	$
	ENDP

	;SEARCHES THE LINE BUFFER FOR THE SPECIFIED LINE NUMBER
	;ON ENTRY:
	;	R0	= LINE NUMBER LSB
	;	R1	= LINE NUMBER MSB
	;ON RETURN:
	;	R0	= VALUE ON ENTRY
	;	R1	= VALUE ON ENTRY
	;	C	= 0 IF LINE FOUND
	;		DPTR	= ADDRESS OF LINE'S INDEX ENTRY
	;	C	= 1 IF LINE NOT FOUND
	;		DPTR	= ADDRESS OF INDEX ENTRY IMMEDIATELY AFTER SPECIFIED LINE NUMBER
	BASICFINDLINENUMBER	PROC
			;SAVE REGISTERS
			MOV		A, R2
			PUSH	ACC
			MOV		A, R3
			PUSH	ACC
			;LOAD LINE COUNT AS LOOP COUNTER
			MOV		A, #BASIC_TCB_OFFS_LINECOUNT
			ADD		A, R6
			MOV		DPL, A
			CLR		A
			ADDC	A, R7
			MOV		DPH, A
			CALL	DPTRWLDXDNN
			MOV		R2, DPL
			MOV		R3, DPH
			;CHECK FOR ZERO LINE COUNT
			MOV		A, R2
			ORL		A, R3
			JZ		BASICFINDLINENUMBERE
			;LOAD LINE BUFFER POINTER
			MOV		A, #BASIC_TCB_OFFS_PTR_LINEINDEX
			ADD		A, R6
			MOV		DPL, A
			CLR		A
			ADDC	A, R7
			MOV		DPH, A
			CALL	DPTRWLDXDNN
		BASICFINDLINENUMBERA:
			;COMPARE LINE NUMBER
			MOVX	A, @DPTR
			CLR		C
			SUBB	A, R0
			INC		DPTR
			MOVX	A, @DPTR
			SUBB	A, R1
			JC		BASICFINDLINENUMBERC
			JNZ		BASICFINDLINENUMBERD
			;LINE NUMBERS EQUAL, LOAD LINE'S CONTENTS ADDRESS
			INC		DPTR
			MOVX	A, @DPTR
			MOV		R2, A
			INC		DPTR
			MOVX	A, @DPTR
			MOV		DPH, A
			MOV		DPL, R2
			CLR		C
		BASICFINDLINENUMBERB:
			;RESTORE REGISTERS & RETURN
			POP		ACC
			MOV		R3, A
			POP		ACC
			XCH		A, R2
			RET
		BASICFINDLINENUMBERC:
			;LINE NUMBER NOT FOUND, RETURN NEAREST LINE NUMBER'S INDEX ENTRY
			MOV		A, DPL
			CLR		C
			SUBB	A, #0x01
			MOV		DPL, A
			MOV		A, DPH
			SUBB	A, #0x00
			MOV		DPH, A
			SETB	C
			SJMP	BASICFINDLINENUMBERB
		BASICFINDLINENUMBERD:
			;LINE NUMBERS NOT EQUAL, POINT TO NEXT ENTRY
			INC		DPTR
			INC		DPTR
			;DECREMENT LOOP COUNTER
			DJNZ	R2, BASICFINDLINENUMBERA
			DJNZ	R3, BASICFINDLINENUMBERA
		BASICFINDLINENUMBERE:
			;LOOP COUNTER ZERO, LINE NOT FOUND
			MOV		DPTR, #0x0000
			SETB	C
			SJMP	BASICFINDLINENUMBERB
	ENDP

	BASICKEYABS	PROC
			JMP	$
	ENDP

	BASICKEYEXP	PROC
			JMP	$
	ENDP

	BASICKEYFOR	PROC
			JMP	$
	ENDP

	BASICKEYGOSUB	PROC
			JMP	$
	ENDP

	BASICKEYGOTO	PROC
			JMP	$
	ENDP

	BASICKEYIF	PROC
			JMP	$
	ENDP

	BASICKEYINPUT	PROC
			JMP	$
	ENDP

	BASICKEYLET	PROC
			JMP	$
	ENDP

	BASICKEYMOD	PROC
			JMP	$
	ENDP

	BASICKEYNEXT	PROC
			JMP	$
	ENDP

	BASICKEYPRINT	PROC
			JMP	$
	ENDP

	BASICKEYREM	PROC
			JMP	$
	ENDP

	BASICKEYRETURN	PROC
			JMP	$
	ENDP

	BASICKEYRND	PROC
			JMP	$
	ENDP

	BASICKEYSTOP	PROC
			JMP	$
	ENDP

	;INSERTS A NEW ENTRY INTO THE LINE INDEX
	;ON ENTRY:
	;	R0	= LINE NUMBER LSB
	;	R1	= LINE NUMBER MSB
	;ON RETURN:
	;	R0	= VALUE ON ENTRY
	;	R1	= VALUE ON ENTRY
	BASICLINEINSERT	PROC
			;SAVE REGISTERS
			MOV		A, R2
			PUSH	ACC
			MOV		A, R3
			PUSH	ACC
			;LOAD LINE COUNT AS LOOP COUNTER
			MOV		A, #BASIC_TCB_OFFS_LINECOUNT
			ADD		A, R6
			MOV		DPL, A
			CLR		A
			ADDC	A, R7
			MOV		DPH, A
			CALL	DPTRWLDXDNN
			MOV		R2, DPL
			MOV		R3, DPH
			;CHECK FOR ZERO LINE COUNT
			MOV		A, R2
			ORL		A, R3
			JZ		BASICLINEINSERTE
			;LOAD LINE BUFFER POINTER
			MOV		A, #BASIC_TCB_OFFS_PTR_LINEINDEX
			ADD		A, R6
			MOV		DPL, A
			CLR		A
			ADDC	A, R7
			MOV		DPH, A
			CALL	DPTRWLDXDNN
		BASICLINEINSERTA:
			;COMPARE LINE NUMBER
			MOVX	A, @DPTR
			CLR		C
			SUBB	A, R0
			INC		DPTR
			MOVX	A, @DPTR
			SUBB	A, R1
			JC		BASICLINEINSERTC
			JNZ		BASICLINEINSERTD
			;LINE NUMBERS EQUAL, LOAD LINE'S CONTENTS ADDRESS
			INC		DPTR
			MOVX	A, @DPTR
			MOV		R2, A
			INC		DPTR
			MOVX	A, @DPTR
			MOV		DPH, A
			MOV		DPL, R2
			CLR		C
		BASICLINEINSERTB:
			;RESTORE REGISTERS & RETURN
			POP		ACC
			MOV		R3, A
			POP		ACC
			XCH		A, R2
			RET
		BASICLINEINSERTC:
			;LINE NUMBER NOT FOUND, RETURN NEAREST LINE NUMBER'S INDEX ENTRY
			MOV		A, DPL
			CLR		C
			SUBB	A, #0x01
			MOV		DPL, A
			MOV		A, DPH
			SUBB	A, #0x00
			MOV		DPH, A
			SETB	C
			SJMP	BASICLINEINSERTB
		BASICLINEINSERTD:
			;LINE NUMBERS NOT EQUAL, POINT TO NEXT ENTRY
			INC		DPTR
			INC		DPTR
			;DECREMENT LOOP COUNTER
			DJNZ	R2, BASICLINEINSERTA
			DJNZ	R3, BASICLINEINSERTA
		BASICLINEINSERTE:
			;LOOP COUNTER ZERO, LINE NOT FOUND
			MOV		DPTR, #0x0000
			SETB	C
			SJMP	BASICLINEINSERTB
	ENDP

	;STORE LINE USER HAS ENTERED WITH A LINE LABEL
	;NEW LINE NUMBER BECOMES CURRENT LINE NUMBER
	BASICLINELABEL	PROC
			;CONVERT LINE LABEL TO
	ENDP

	;STORE LINE USER HAS ENTERED WITH A LINE NUMBER
	;NEW LINE NUMBER BECOMES CURRENT LINE NUMBER
	BASICLINENUMBER	PROC
			;CONVERT LINE NUMBER FROM STRING TO 16 BIT VALUE
			MOVX	A, @DPTR
			MOV		R4, A
			INC		DPTR
			MOVX	A, @DPTR
			MOV		R3, A
			INC		DPTR
			MOVX	A, @DPTR
			MOV		R2, A
			INC		DPTR
			MOVX	A, @DPTR
			MOV		R1, A
			INC		DPTR
			MOVX	A, @DPTR
			MOV		R0, A
			INC		DPTR
			MOVX	A, @DPTR
			JZ		BASICLINENUMBERD
			;INVALID LINE NUMBER
		BASICLINENUMBERA:
			MOV		DPTR, #BASICSTRERRLINENUM
			SETB	C
		BASICLINENUMBERC:
			RET
		BASICLINENUMBERD:
			CALL	INTASC2WORD
			JC		BASICLINENUMBERA
			;SEARCH FOR LINE NUMBER IN LINE INDEX
			CALL	BASICFINDLINENUMBER
			JC		BASICLINENUMBERD
			;LINE NUMBER FOUND, REPLACE EXISTING LINE
			JMP		BASICLINEREPLACE
		BASICLINENUMBERD:
			;LINE NUMBER NOT FOUND, INSERT LINE NUMBER INTO LINE INDEX
			CALL	BASICLINEINSERT
			;PARSE LINE'S CONTENTS

	ENDP

	BASICLOGICAND	PROC
			JMP	$
	ENDP

	BASICLOGICOR	PROC
			JMP	$
	ENDP

	BASICRELEQ	PROC
			JMP	$
	ENDP

	BASICRELGR	PROC
			JMP	$
	ENDP

	BASICRELGREQ	PROC
			JMP	$
	ENDP

	BASICRELLT	PROC
			JMP	$
	ENDP

	BASICRELLTEQ	PROC
			JMP	$
	ENDP

	BASICRELNE	PROC
			JMP	$
	ENDP

	PROMPT:
		DB	'EmBASIC>', 0x0D, 0x0A, 0x00

#include "EmBASIC_51.inc"

END